#include "push_client.h"
#include "push_client_hub.h"
#include "push_client_exit.h"
#include "push_client_timer.h"
#include "push_client_config.h"
#include "push_client_thread.h"
#include "list.h"

typedef struct _PCTimerNode
{
	struct list_head struNode;
}PCTimerNode, *PPCTimerNode;

typedef struct _PCTimerHead
{
	int iTick;
	int iMSecond;
	int iNum;	  //用于记录有多少用户子使用该定时器
	int iTimerFlag;   //定时器状态,是持续存在还是,只是一致存在
	int iTimerStatus; //是否正在进行处理
	int iNextPos;
	int iPrevPos;
	unsigned long ulData; //私有数据
	pthread_mutex_t struMutex;
	int (*func)(unsigned long);
	void (*free)(unsigned long);
//	struct list_head struHead;
}PCTimerHead, *PPCTimerHead;

enum
{
	PUSH_CLIENT_TIMER_IDLE,
	PUSH_CLIENT_TIMER_READY,
	PUSH_CLIENT_TIMER_RUNNING,
	PUSH_CLIENT_TIMER_MAX
};

//static struct list_head gStruTimerList = INIT_LIST_HEAD(gStruTimerList);

#define TIMER_BASE 10
#define MAX_COUNT  10
#define PUSH_CLIENT_TIMER_ARRAY  110000  //这是为了防止使用每一秒只产生10个连接造成的
static int giThreadID = 0;
static int giTimerCnt = 0;
static int giTimeTick = 0;
static int giResetTick = 0;
static PCTimerHead gStruTimerArray[PUSH_CLIENT_TIMER_ARRAY];
static pthread_mutex_t gStruCntMutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_mutex_t gStruTickMutex = PTHREAD_MUTEX_INITIALIZER;
//static pthread_cond_t gStruTimerCond = PTHREAD_COND_INITIALIZER;

static int
push_client_get_timer_node()
{
	int i = 0;

	for( ; i < PUSH_CLIENT_TIMER_ARRAY; i++ )
	{
		pthread_mutex_lock(&gStruTimerArray[i].struMutex);
		if( gStruTimerArray[i].iMSecond == -1 )
		{
			pthread_mutex_unlock(&gStruTimerArray[i].struMutex);
			continue;
		}
		else if( gStruTimerArray[i].iTick == gStruTimerArray[i].iMSecond )
		{
			if( gStruTimerArray[i].func )
			{
				gStruTimerArray[i].func(gStruTimerArray[i].ulData);
				if( gStruTimerArray[i].iTimerFlag == PUSH_CLIENT_TIMER_STATUS_INSTANT )
				{
					push_client_destroy_timer(i);
				}
			}
			gStruTimerArray[i].iTick = 0;
		}
		else
		{
			/*PC_DEBUG("second = %d, iTick = %d\n", 
									gStruTimerArray[i].iTick, gStruTimerArray[i].iSecond );*/
			gStruTimerArray[i].iTick++;
		}
		pthread_mutex_unlock(&gStruTimerArray[i].struMutex);
	}

	return PUSH_CLIENT_OK;
}


static int
push_client_handle_timer(
	struct list_head *pStruNode
)
{
	int iRet = 0;
	int ID = 0;
	PCHubNode *pStruHN = NULL;
	//PCTimerNode *pStruNode;

	pStruHN = list_entry(pStruNode, PCHubNode, struNode);

	ID = pStruHN->iSockfd;

	if( gStruTimerArray[ID].func )
	{
		gStruTimerArray[ID].func(gStruTimerArray[ID].ulData);
	}
	if( gStruTimerArray[ID].iTimerFlag != PUSH_CLIENT_TIMER_STATUS_CONSTANT )
	{
		push_client_destroy_timer(ID);
	}

	PUSH_CLIENT_FREE(pStruHN);

	return PUSH_CLIENT_OK;
}

int
push_client_check_timer(
	int iCount
)
{
	int i = 0;
	int iCnt = 0;
	PCHubNode *pStruHN = NULL;

	for( i = 0; i < PUSH_CLIENT_TIMER_ARRAY && iCnt < giTimerCnt; i++ )
	{
		pthread_mutex_lock(&gStruTimerArray[i].struMutex);
		if( gStruTimerArray[i].iTimerStatus == PUSH_CLIENT_TIMER_IDLE )
		{
			goto next;
		}
		iCnt++;
		gStruTimerArray[i].iTick++;
		if( gStruTimerArray[i].iTick >= gStruTimerArray[i].iMSecond )
		{
			//gStruTimerArray[i].iTick = 0;
			PUSH_CLIENT_CALLOC(pStruHN, PCHubNode, 1);
			/*pStruHN = (PCHubNode *)calloc(1, sizeof(PCHubNode));
			if( !pStruHN )
			{
				PC_ERROR("calloc: %s\n", strerror(errno));
				exit(0);
			}*/
			pStruHN->iSockfd = i;
			push_client_add_thread_pool_node(giThreadID, &pStruHN->struNode);
		}
next:
		pthread_mutex_unlock(&gStruTimerArray[i].struMutex);
	}
}

void
push_client_reset_timer()
{
	pthread_mutex_lock(&gStruTickMutex);
	giResetTick = giTimeTick;
	pthread_mutex_unlock(&gStruTickMutex);
}

void
push_client_get_tick(
	int *piTick	
)
{
	pthread_mutex_lock(&gStruTickMutex);
	(*piTick) = giTimeTick;// - giResetTick;
	pthread_mutex_unlock(&gStruTickMutex);
}


static void *
push_client_timer_count(
	void *pData
)
{
	int iRet = 0;
	int iCount = 0;
	//int iUsec = 1000;
	//int iTimes = 0;
	struct timespec struStart, struEnd;

	memset(&struStart, 0, sizeof(struStart));
	memset(&struEnd, 0, sizeof(struEnd));
	while(1)
	{
		iRet = push_client_check_exit();
		if( iRet == PUSH_CLIENT_OK )
		{
			pthread_exit(NULL);;
		}
		sleep(1);
		iRet = push_client_check_exit();
		if( iRet == PUSH_CLIENT_OK )
		{
			pthread_exit(NULL);;
		}
		//clock_gettime(CLOCK_MONOTONIC, &struStart);
//		iCount++;
//		if( iCount == MAX_COUNT )
		{
			pthread_mutex_lock(&gStruTickMutex);
			giTimeTick++;
			PC_ERROR("timtikc = %d\n", giTimeTick);
			pthread_mutex_unlock(&gStruTickMutex);
		}
		push_client_total_link_print();

		push_client_check_timer(0);
	}
}

int 
push_client_check_timer_duration()
{
	int iTick = 0;
	PCConfig *pStruConf = NULL;

	push_client_get_config_ptr(&pStruConf);
	pthread_mutex_lock(&gStruTickMutex);
	iTick = giTimeTick;
	pthread_mutex_unlock(&gStruTickMutex);
	PC_DEBUG("iTick = %d = %d\n", iTick, pStruConf->uiDurationTime);
	if( iTick >= pStruConf->uiDurationTime )
	{
		return PUSH_CLIENT_OK;
	}

	return PUSH_CLIENT_ERR;
}

int
push_client_init_timer(int iThreadNum)
{
	int i = 0;
	pthread_t th;
	pthread_attr_t struAttr;

	memset(gStruTimerArray, 0, sizeof(gStruTimerArray));
	for( i = 0; i < PUSH_CLIENT_TIMER_ARRAY; i++ )
	{
		gStruTimerArray[i].iMSecond = -1;
		pthread_mutex_init(&gStruTimerArray[i].struMutex, NULL);
	}

	if( iThreadNum <= 0 )
	{
		return PUSH_CLIENT_OK;		
	}

	pthread_attr_init(&struAttr);
	pthread_attr_setstacksize(&struAttr, 32 * 1024);

	if(pthread_create(&th, &struAttr, push_client_timer_count, NULL))
	{
		PC_ERROR( "pthread_creat err: %s\n", strerror(errno) );
		return PUSH_CLIENT_ERR;
	}
	return push_client_create_thread_pool(iThreadNum, "timer", NULL, NULL, push_client_handle_timer, &giThreadID);
}

int
push_client_uninit_timer()
{
	int i = 0;
	for( ; i < PUSH_CLIENT_TIMER_ARRAY; i++ )	
	{
		pthread_mutex_destroy(&gStruTimerArray[i].struMutex);
	}

	return PUSH_CLIENT_OK;
}

static void
push_client_add_timer_list(
	int iFirstPos,		
	int iCurPos
)
{
	int iPrevPos = 0;

	iPrevPos = gStruTimerArray[iFirstPos].iPrevPos;
	gStruTimerArray[iFirstPos].iPrevPos = iCurPos;
	gStruTimerArray[iPrevPos].iNextPos  = iCurPos;
	gStruTimerArray[iCurPos].iPrevPos   = iPrevPos;
	gStruTimerArray[iCurPos].iNextPos   = iFirstPos;
}

int
push_client_create_timer(
	int iNum,
	int iMSecond,
	int iFlag,
	unsigned long ulData,
	int (*func)(unsigned long),
	void (*free_data)(unsigned long),
	int *piTimerID
)
{
	int i = 0;
	/*int iPos = 0;
	int iTick = 0;

	pthread_mutex_lock(&gStruTickMutex);
	iTick = giTimeTick;
	pthread_mutex_unlock(&gStruTickMutex);*/

	for( ; i < PUSH_CLIENT_TIMER_ARRAY; i++ )
	{
		if( gStruTimerArray[i].iMSecond == -1 )
		{
			//PC_DEBUG("--------------------------------------- i = %d\n", i);
			pthread_mutex_lock(&gStruTimerArray[i].struMutex);
			gStruTimerArray[i].iMSecond = iMSecond;
			gStruTimerArray[i].iNum = iNum;
			gStruTimerArray[i].func = func;
			gStruTimerArray[i].iTick = 0;
			gStruTimerArray[i].ulData = ulData;
			gStruTimerArray[i].free = free_data;
			gStruTimerArray[i].iTimerFlag = iFlag;
			gStruTimerArray[i].iTimerStatus = PUSH_CLIENT_TIMER_READY;
			if(piTimerID)
			{
				(*piTimerID) = i;
			}
			/*iPos = iTick % TIMER_BASE;		
			if( gStruTimerArray[iPos].iNextPos == -1 )
			{
				gStruTimerArray[iPos].iNextPos = i;
				gStruTimerArray[iPos].iPrevPos = i;
			}
			else
			{
				push_client_add_timer_list(iPos, i);
			}*/

			pthread_mutex_unlock(&gStruTimerArray[i].struMutex);
			pthread_mutex_lock(&gStruCntMutex);
			giTimerCnt++;
			PC_DEBUG("--------------------------------------- giTimerCnt = %d\n", giTimerCnt);
			pthread_mutex_unlock(&gStruCntMutex);
			return PUSH_CLIENT_OK;
		}
	}

	return PUSH_CLIENT_ERR;
}

int
push_client_destroy_timer(
	int iTimerID
)
{	
	if( iTimerID >= PUSH_CLIENT_TIMER_ARRAY || iTimerID < 0 )
	{
		return PUSH_CLIENT_OK;
	}
/*	if( gStruTimerArray[iTimerID].iNum <= 0 || --gStruTimerArray[iTimerID].iNum > 0 )
	{
		return PUSH_CLIENT_OK;
	}*/
	pthread_mutex_lock(&gStruTimerArray[iTimerID].struMutex);
	gStruTimerArray[iTimerID].func = NULL;
	gStruTimerArray[iTimerID].iTimerStatus = PUSH_CLIENT_TIMER_IDLE;
	gStruTimerArray[iTimerID].iMSecond = -1;
	if( gStruTimerArray[iTimerID].free )
	{
		PC_DEBUG("\n")
		gStruTimerArray[iTimerID].free(gStruTimerArray[iTimerID].ulData);
	}
	gStruTimerArray[iTimerID].free = NULL;
	pthread_mutex_unlock(&gStruTimerArray[iTimerID].struMutex);
	pthread_mutex_lock(&gStruCntMutex);
	giTimerCnt--;
	pthread_mutex_unlock(&gStruCntMutex);


	return PUSH_CLIENT_OK;
}
