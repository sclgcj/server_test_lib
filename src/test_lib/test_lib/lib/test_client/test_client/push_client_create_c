#include "push_client.h"
#include "push_client_hub.h"
#include "push_client_exit.h"
#include "push_client_data.h"
#include "push_client_boot.h"
#include "push_client_listen.h"
#include "push_client_crypto.h"
#include "push_client_create.h"
#include "push_client_result.h"
#include "push_client_thread.h"
#include "push_client_rendezvous.h"
#include "push_client_mobile_cmd.h"
#include "push_client_recv_check.h"
#include "push_client_user_center.h"
#include "semaphore.h"
#include <sys/epoll.h>
//#include "push_client_message.h"

typedef struct _PCCreateLink
{
	struct in_addr struAddr; //unsigned int uiIP;
	unsigned short usPort;
	void					 *pData;
	struct list_head struNode;
}PCCreateLink ,*PPCCreateLink;

typedef struct _PCLinkData
{
	int iRID;
	char sRouterID[PUSH_CLIENT_ROUTERID_LENGTH];
	char sQt[PUSH_CLIENT_QT_LENGTH];
	char sUid[PUSH_CLIENT_UID_LENGTH];
/*	char sUserID[64];
	char sToken[256];
	PCDevice *pStruDev;*/
	cJSON *pStruRouter;
}PCLinkData, *PPCLinkData;

static int giThreadID = 0;
static sem_t gSem;
static int giLinkCount = 0;
static int giPushDataCnt = 0;
static int giCreateLink = 0;
static int giReset = 0;
static int giSendCount = 0;
static pthread_mutex_t gStruLCMutex  = PTHREAD_MUTEX_INITIALIZER;
static pthread_mutex_t gStruSCMutex  = PTHREAD_MUTEX_INITIALIZER;
static pthread_mutex_t gStruPDCMutex = PTHREAD_MUTEX_INITIALIZER;

static int
push_client_get_message(
	char *sMessage,
	int  iMsgLen
)
{
	int iRandNum = 0;

	iRandNum = random();

	snprintf(sMessage, iMsgLen, "%d:push_client_message1", iRandNum);

	return PUSH_CLIENT_OK;
}

int
push_client_set_block_fd(
	int iSockfd
)
{
	int iFlag = 0;

	iFlag = fcntl(iSockfd, F_GETFL);
	if( iFlag < 0 )
	{
		PC_ERROR("FCNTL error:%s\n", strerror(errno));
		return PUSH_CLIENT_ERR;
	}
	iFlag &= ~O_NONBLOCK;
	iFlag = fcntl(iSockfd,F_SETFL, iFlag);
	if( iFlag < 0 )
	{
		PC_ERROR("fcntl F_SETFL err: %s\n", strerror(errno));
	}

	return PUSH_CLIENT_OK;
}

static int
push_client_set_nonblock_fd(
	int iSockfd
)
{
	int iFlag = 0;

	iFlag = fcntl(iSockfd, F_GETFL);
	if( iFlag < 0 )
	{
		PC_ERROR("FCNTL error:%s\n", strerror(errno));
		return PUSH_CLIENT_ERR;
	}
	iFlag |= O_NONBLOCK;
	iFlag = fcntl(iSockfd,F_SETFL, iFlag);
	if( iFlag < 0 )
	{
		PC_ERROR("fcntl F_SETFL err: %s\n", strerror(errno));
	}

	return PUSH_CLIENT_OK;
}

int
push_client_set_listen_sockopt(
	int iSockfd
)
{
	int iReuseaddr = 1;
	struct timeval struST;
	struct linger struLinger;

	if(setsockopt(iSockfd, SOL_SOCKET ,SO_REUSEADDR,(const char*)&iReuseaddr,sizeof(int)) < 0)
	{
		PC_ERROR("set SO_REUSEADDR fail:[%d] %s\n", iSockfd, strerror(errno));
		return PUSH_CLIENT_ERR;
	}

	if( push_client_set_nonblock_fd(iSockfd) != PUSH_CLIENT_OK )
	{
		PC_ERROR("set nonblock_fd error\n");
		return PUSH_CLIENT_ERR;
	}
	//if(setsockopt(iSockfd, SOL_SOCKET, SO))

	return PUSH_CLIENT_OK;
}

static int
push_client_set_sockopt(
	int iSockfd,
	int iRecvTimeout
)
{
	int iReuseaddr = 1;
	int	iBufferSize = 1024 * 1024;
	//int iBuffserSize =  1024 * 1024;
	struct timeval struST;
	struct linger struLinger;
	PCConfig *pStruConf = NULL;

	push_client_get_config_ptr(&pStruConf);

	if(setsockopt(iSockfd, SOL_SOCKET ,SO_REUSEADDR,(const char*)&iReuseaddr,sizeof(int)) < 0)
	{
		PC_ERROR("set SO_REUSEADDR fail:[%d] %s\n", iSockfd, strerror(errno));
		return PUSH_CLIENT_ERR;
	}

	struLinger.l_onoff = 1;
	struLinger.l_linger = 0;
	if( setsockopt(iSockfd, SOL_SOCKET, SO_LINGER, (void*)&struLinger, sizeof(struLinger)) )
	{
		PC_ERROR("set SO_LINGER fail: [%d] %s\n", iSockfd, strerror(errno));
		return PUSH_CLIENT_ERR;
	}

	// 由于设置为费阻塞模式, 所以 这一块基本上没用了 
	struST.tv_sec = iRecvTimeout;
	struST.tv_usec = 0;
	if(setsockopt(iSockfd, SOL_SOCKET, SO_RCVTIMEO, &struST, sizeof(struST)) < 0)
	{
		PC_DEBUG("set SOL_SOCKET:SO_RCVTIMEO error:[%d] -  %s", iSockfd, strerror(errno));
		return PUSH_CLIENT_ERR;
	}
	if(setsockopt(iSockfd, SOL_SOCKET, SO_RCVTIMEO, &struST, sizeof(struST)) < 0)
	{
		PC_DEBUG("set SOL_SOCKET:SO_SNDTIMEO error:[%d] -  %s", iSockfd, strerror(errno));
		return PUSH_CLIENT_ERR;
	}
	//if( pStruConf->iType == PUSH_CLIENT_TYPE_SERVER )
	{
		if(setsockopt(iSockfd, SOL_SOCKET, SO_RCVBUF, (char*)&iBufferSize, sizeof(iBufferSize)))
		{
			PC_ERROR("setsockopt error:%s\n", strerror(errno));
			PUSH_CLIENT_ERR;
		}
		if(setsockopt(iSockfd, SOL_SOCKET, SO_SNDBUF, (char*)&iBufferSize, sizeof(iBufferSize)))
		{
			PC_ERROR("setsockopt error:%s\n", strerror(errno));
			PUSH_CLIENT_ERR;
		}
	}


	if( push_client_set_nonblock_fd(iSockfd) != PUSH_CLIENT_OK )
	{
		PC_ERROR("set nonblock_fd error\n");
		return PUSH_CLIENT_ERR;
	}
	//if(setsockopt(iSockfd, SOL_SOCKET, SO))

	return PUSH_CLIENT_OK;
} 
				

int
push_client_loop_connect(
	int iSockfd,
	int iRecvTimeout,
	struct sockaddr_in *pStruAddr, 
	int iSize
)
{
	int i = 0;
	int iRet = 0;
	int iConnect_time = iRecvTimeout * 1000;

	for( ; i < iConnect_time; i++ )
	{
		iRet = push_client_check_exit();
		if( iRet == PUSH_CLIENT_OK )
		{
			return PUSH_CLIENT_FAIL_PROGRAM_EXIT;
		}

		iRet = connect(iSockfd, (struct sockaddr *)pStruAddr, iSize);
		if(iRet < 0)
		{
			if( errno == EISCONN )
			{
				return PUSH_CLIENT_OK;
			}
			else if( errno == EINTR )
			{
				continue;
			}
			else if(errno != EINPROGRESS && errno != EALREADY && errno != EWOULDBLOCK)
			{
				PC_ERROR("connect_error(%s:%d) :%s\n", inet_ntoa(pStruAddr->sin_addr), ntohs(pStruAddr->sin_port), strerror(errno));
				return PUSH_CLIENT_ERR;
			}
			return PUSH_CLIENT_FAIL_WOULDBLOCK;
		}
		break;
	}

	return PUSH_CLIENT_OK;
}

int
push_client_create_socket(
	int		iProtocol,
	struct in_addr	struIP,
	unsigned short	usPort,
	PCConfig	*pStruConf,
	int		*piSockfd
)
{
	int iRet = 0;
	int iSize = 0;
	struct sockaddr_in struAddr;

	if( iProtocol == PUSH_CLIENT_PROTO_TCP )
	{
		(*piSockfd) = socket(AF_INET, SOCK_STREAM, 0);
	}
	else
	{
		(*piSockfd) = socket(AF_INET, SOCK_DGRAM, 0);
	}
	if( *piSockfd < 0 ){
		PC_ERROR("socket_err: %s", strerror(errno));
		return PUSH_CLIENT_ERR;
	}
	PC_ERROR("piSockfd = %d\n", *piSockfd);

	PC_ERROR("clientip = %s, clientPort = %d\n", inet_ntoa(struIP), usPort);
	iSize = sizeof(struAddr);
	memset(&struAddr, 0, iSize);
	struAddr.sin_family = AF_INET; 
	//PC_DEBUG("usPort = %d\n", usPort);
	struAddr.sin_port = htons(usPort); 
//	struAddr.sin_port = 0;
	struAddr.sin_addr = struIP;
	//PC_DEBUG("ip = %x, port = %d\n", struIP.s_addr, usPort);
	
	iRet = push_client_set_sockopt(*piSockfd, pStruConf->iRecvTimeout);
	if( iRet != PUSH_CLIENT_OK )
	{
		goto out;
	}

	//if((usPort - 1) % (pStruConf->iMapCnt + 2) != 0)
	{
		if( bind((*piSockfd), (struct sockaddr*)&struAddr, iSize) < 0 )
		{
			PC_ERROR("bind_sock(%d)(ip-%s, port-%d): %s\n", 
					(*piSockfd), inet_ntoa(struAddr.sin_addr), usPort, strerror(errno));
			iRet = PUSH_CLIENT_FAIL_BIND_SOCKET_ERR;
			goto out;
		}
	}

	return PUSH_CLIENT_OK;
out:
	close(*piSockfd);
	return iRet;
}

static int
push_client_set_rid(
	PCConfig   *pStruConf,
	int				 *iCnt
)
{
/*	int iRet = PUSH_CLIENT_OK;


	if( iRet != PUSH_CLIENT_OK )
	{
		return iRet;
	}
	sprintf(pStruPC->sRouterID, "%d", pStruPC->iRid);
	if( pStruConf->iType == PUSH_CLIENT_TYPE_CLIENT )
	{
		sprintf(pStruPC->sLogFile, "/tmp/log/log_mobile_%d.txt", pStruPC->iRid);
	}
	else
	{
		sprintf(pStruPC->sLogFile, "/tmp/log/log_gateway_%d.txt", pStruPC->iRid);
	}

	return iRet;*/
}

int
push_client_create_tcp_link(
	int		iMapCnt,
	PCConfig	*pStruConf,
	PushClient 	*pStruPC,
	unsigned int    uiIP,
	unsigned short  usPort,
	unsigned short  usSrcPort,
	int		*piSockfd
)
{
	int iRet = 0;
	void *pData = NULL;
	int iSize = sizeof(struct sockaddr_in);
	struct sockaddr_in struAddr;

	memset(&struAddr, 0, sizeof(struAddr));
	struAddr.sin_family = AF_INET;
	struAddr.sin_port = htons(usPort);
	struAddr.sin_addr.s_addr = uiIP;
	PC_ERROR("ip === %s:%d\n", inet_ntoa(struAddr.sin_addr), usPort);

	memset(&pStruPC->struSendAddr, 0, sizeof(struAddr));
	memcpy(&pStruPC->struSendAddr, &struAddr, sizeof(struAddr));
	pStruPC->uiStatus = PUSH_CLIENT_ERR;
//	pStruPC->struPeerIP = struAddr.sin_addr;
	//pStruPC->usPeerPort = usPort;
	clock_gettime(CLOCK_MONOTONIC, pStruPC->pStruSendData);
	push_client_write_mmap_data(pStruPC->struClientIP.s_addr, usSrcPort, pStruPC);
	pStruPC->iEvents = 0;

	iRet = PUSH_CLIENT_OK;
	if( iRet == PUSH_CLIENT_OK )
	{
		pStruPC->uiStatus = PUSH_CLIENT_OK;
		clock_gettime(CLOCK_MONOTONIC, &pStruPC->struCreateTime);
		push_client_write_mmap_data(pStruPC->struClientIP.s_addr, pStruPC->usClientPort, pStruPC);
		//In constant link-creating situation, it is not work well. Be careful, if wating to use 
		//this fuction, please make create_link == total_link. 
		/*if( pStruConf->iOpenRendezvous )
		{
			push_client_set_rendezvous();
		}*/
		PC_ERROR("\n");
		iRet = push_client_loop_connect(*piSockfd, pStruConf->iRecvTimeout, &struAddr, iSize);	
		if( iRet != PUSH_CLIENT_OK )
		{
			if( iRet != PUSH_CLIENT_FAIL_WOULDBLOCK )
			{
				push_client_set_fail_value(PUSH_CLIENT_CONNECT_TO_NAT_SERVER, PUSH_CLIENT_FAIL_ADDLISTENER_ERR, pStruPC);
				return iRet;	
			}
		}
	}
	else
	{
		pStruPC->iEvents = (EPOLLONESHOT | EPOLLIN);
	}

	PC_DEBUG("sockdf = %d\n", *piSockfd);
	iRet = push_client_add_listen_sockfd(iMapCnt, (*piSockfd), (void*)pStruPC, pStruPC);
	if( iRet != PUSH_CLIENT_OK )
	{
		push_client_set_fail_value(PUSH_CLIENT_ADD_LISTEN_SOCKFD, PUSH_CLIENT_FAIL_ADDLISTENER_ERR, pStruPC);
		return iRet;
	}

	return PUSH_CLIENT_OK;
}

int
push_client_create_udp_link(
	int            iMapCnt,
	unsigned int   uiIP,
	unsigned int   uiClientIP,
	unsigned short usPort,
	unsigned short usSrcPort,
	PCConfig			 *pStruConf,
	PushClient		 *pStruPC,
	int						 *piSockfd
)
{
	int iRet = 0;
	void *pData = NULL;
	struct in_addr struAddr;

	struAddr.s_addr = uiClientIP;
	iRet =  push_client_create_socket(PUSH_CLIENT_PROTO_UDP, struAddr, usSrcPort, pStruConf, piSockfd);
	if( iRet != PUSH_CLIENT_OK )
	{
		push_client_set_fail_value(PUSH_CLIENT_CONNECT_TO_SERVER, iRet, pStruPC);
		return iRet;
	}
//	push_client_write_mmap_data(pStruPC->struClientIP.s_addr, usSrcPort, pStruPC);
	//push_client_get_pushclient_data(pStruPC->struClientIP.s_addr, usSrcPort, &pData);
	pStruPC->iEvents = (EPOLLONESHOT | EPOLLIN);
	iRet = push_client_add_listen_sockfd(iMapCnt, (*piSockfd), (void*)pStruPC, pStruPC);
	if( iRet != PUSH_CLIENT_OK )
	{
		push_client_set_fail_value(PUSH_CLIENT_ADD_LISTEN_SOCKFD, PUSH_CLIENT_FAIL_ADDLISTENER_ERR, pStruPC);
		return iRet;
	}
	//pStruPC->pConnFunc((unsigned long)pStruPC);
	/*if( pStruConf->iType == PUSH_CLIENT_TYPE_CLIENT )
	{
		pthread_mutex_lock(pStruPC->pStruResultMutex);
		*(pStruPC->puiTick) = PUSH_CLIENT_CHECK_TICK_STOP;
		*(pStruPC->puiStatus) = PUSH_CLIENT_STATUS_SEND_TEST_DATA;
		pthread_mutex_unlock(pStruPC->pStruResultMutex);
		clock_gettime(CLOCK_MONOTONIC, &pStruPC->struSendBoot);
		push_client_add_hub(0, (unsigned long)pStruPC);
	}*/

	return iRet;
}

int
push_client_uninit_client(
	PushClient *pStruPC
)
{
	PUSH_CLIENT_FREE(pStruPC->puiHubStatus);
	PUSH_CLIENT_FREE(pStruPC->puiHubTick);
	PUSH_CLIENT_FREE(pStruPC->pStruHubSendData);
	PUSH_CLIENT_FREE(pStruPC->pusMapPortCnt);
	PUSH_CLIENT_FREE(pStruPC->pusAssistantCnt);
	PUSH_CLIENT_FREE(pStruPC->pStruAssistantInfo);
	PUSH_CLIENT_FREE(pStruPC->pStruED);
	PUSH_CLIENT_FREE(pStruPC->piRealClient);
	PUSH_CLIENT_FREE(pStruPC->puiResult);
	PUSH_CLIENT_FREE(pStruPC->puiStatus);
	PUSH_CLIENT_FREE(pStruPC->puiTick);
	PUSH_CLIENT_FREE(pStruPC->sRandKey);
	PUSH_CLIENT_FREE(pStruPC->pStruSendData);
	//PUSH_CLIENT_FREE(pStruPC->puiLogStatus);
	//PUSH_CLIENT_FREE(pStruPC->piAssistantSockfd);
	//PUSH_CLIENT_FREE(pStruPC->piAssistantStatus);
	PUSH_CLIENT_FREE(pStruPC->sRouterArray);
	if( pStruPC->pRouterJson )
	{
		cJSON_Delete((cJSON*)pStruPC->pRouterJson);
	}
	//PUSH_CLIENT_FREE(pStruPC->puiLogStatus);
	//PUSH_CLIENT_FREE(pStruPC->puiPushTick);
//	PUSH_CLIENT_FREE(pStruPC->pStruPushTime);

	PUSH_CLIENT_FREE(pStruPC->pStruHead);
	PUSH_CLIENT_FREE(pStruPC->pStruConnectHead);
	PUSH_CLIENT_FREE(pStruPC->pStruAssistantHead);
	if( pStruPC->pStruResultMutex )
	{
		pthread_mutex_destroy(pStruPC->pStruResultMutex);
		PUSH_CLIENT_FREE(pStruPC->pStruResultMutex);
	}
	if( pStruPC->pStruConnectMutex )
	{
		pthread_mutex_destroy(pStruPC->pStruConnectMutex);
		PUSH_CLIENT_FREE(pStruPC->pStruConnectMutex);
	}
	if( pStruPC->pStruAssistantMutex )
	{
		pthread_mutex_destroy(pStruPC->pStruAssistantMutex);
		PUSH_CLIENT_FREE(pStruPC->pStruAssistantMutex);
	}
	push_client_uninit_interface(pStruPC->pStruInterfaceHead);
	PUSH_CLIENT_FREE(pStruPC->pStruInterfaceHead);
	if( pStruPC->ulProjData )
	{
		cJSON_Delete((cJSON*)pStruPC->ulProjData);
	}
	pthread_mutex_destroy(&pStruPC->struProjDataMutex);
	pStruPC->usInit = 0;
	push_client_write_mmap_data(pStruPC->struClientIP.s_addr, pStruPC->usClientPort, pStruPC);
}

static void
push_client_urldata_alloc(
	char *sLine,
	PCUrlData **pStruUD
)
{
	int iLen = 0;

	PUSH_CLIENT_CALLOC(*pStruUD, PCUrlData, 1);
	iLen = strlen(sLine);
	PUSH_CLIENT_CALLOC((*pStruUD)->sUrl, char, iLen + 1);
	memcpy((*pStruUD)->sUrl, sLine, iLen - 1);
}

static int
push_client_get_url_data(
	PCConfig   *pStruConf, 
	PushClient *pStruPC 
)
{
	int  iLen = 0;
	char *sFile = NULL;
	FILE *pStruFp = NULL;
	char sLine[1024] = { 0 };
	PCUrlData *pStruData = NULL;

	if( pStruConf->sUrlPath[0] == '\0' )
	{
		sFile = "./url.dat";
	}
	else
	{
		sFile = pStruConf->sUrlPath;
	}
	
	pStruFp = fopen(sFile, "r");
	if(!pStruFp)
	{
		PC_ERROR2(pStruPC->sLogFile, "open file %s error: %s\n", sFile, strerror(errno));
		push_client_set_fail(PUSH_CLIENT_OK, PUSH_CLIENT_ERR, pStruPC);
		return PUSH_CLIENT_ERR;
	}
	
	while(fgets(sLine, 1024, pStruFp))
	{
		PC_ERROR2(pStruPC->sLogFile, "sLine = %s\n", sLine);
		push_client_urldata_alloc(sLine, &pStruData);
		pthread_mutex_lock(&pStruPC->struUrlMutex);
		list_add_tail(&pStruData->struNode, &pStruPC->struUrlList);
		pthread_mutex_unlock(&pStruPC->struUrlMutex);
	}

	fclose(pStruFp);

	return PUSH_CLIENT_OK;
}

static void
push_client_init_client(
	PCLinkData		 *pStruLD,
	struct in_addr struIP,
	unsigned short usPort,
	PCConfig			 *pStruConf, 
	PushClient 		 *pStruPC
)
{
	int iRet = 0;
	int iTmp = 0;
	static int iServer = 0;
	static int iRidCount = 0;

	if(pStruConf->iServerDispatch)
	{
		iServer ^= 1;
	}
	else
	{
		iServer = 1;
	}

	PC_DEBUG("\n");
	pStruPC->pStruConf = (void*)pStruConf;
	pStruPC->struServerIP.s_addr = inet_addr(pStruConf->sNatServerAddr1);
	pStruPC->usServerPort = pStruConf->usNatServerPort;
	pStruPC->uiUseFlow = pStruConf->iUseflow;
	pStruPC->struClientIP.s_addr = struIP.s_addr;
	//PC_ERROR("ip = %s\n", inet_ntoa(pStruPC->struClientIP));
	pStruPC->usClientPort = usPort;
	pStruPC->uiTick = 127;  //这个值是用于表示已经停止计数的意思
	clock_gettime(CLOCK_MONOTONIC, &pStruPC->struCreateTime);
	pStruPC->uiAddCheck = pStruConf->iAddCheck;
//	pStruPC->iGatewayTest = pStruConf->iGatewayTest;
	pStruPC->uiFailStep = PUSH_CLIENT_CONNECT_TO_NAT_SERVER;
	pStruPC->uiHubIntervalTime = pStruConf->iPushInterval;
	pStruPC->iInterfaceInterval = pStruConf->iInterfaceInterval * 1000;

	pStruPC->iRid = pStruLD->iRID;
//	pStruPC->pRouterJson = (void*)cJSON_CreateArray();
//	push_client_get_router_array(pStruPC->iRid, pStruConf->iRouterCnt, pStruConf->sRidPath, (cJSON*)pStruPC->pRouterJson);
//	memcpy(pStruPC->sUID, pStruLD->sUid, strlen(pStruLD->sUid));

	PC_DEBUG("=--------------------------------------------------------------------------------sRouterID = %s\n", pStruPC->sRouterID);
	pthread_mutex_lock(&gStruPDCMutex);
	giPushDataCnt++;
	iTmp = giCreateLink++;
//	PC_ERROR2(pStruPC->sLogFile, "iPushDataTotalLink = %d\n", pStruConf->iPushDataTotalLink);
//	PC_ERROR2(pStruPC->sLogFile, "usClientPort = %d\n", pStruPC->usClientPort);
	if( pStruConf->iOpenPush == 1 && giPushDataCnt <= pStruConf->iPushDataTotalLink )
	{
		pStruPC->uiSendData = 1;
	}
	if( giReset == 1 )
	{
		if( giCreateLink < pStruConf->iPushDataTotalLink )
		{
			PC_ERROR("\n");
			exit(0);
		}
		giCreateLink = 0;
	}
	pthread_mutex_unlock(&gStruPDCMutex);
	if( pStruConf->iType == PUSH_CLIENT_TYPE_CLIENT )
	{
		sprintf(pStruPC->sCityVer, "%s_%d.txt", pStruConf->sCityVerPath, pStruPC->iRid);
		sprintf(pStruPC->sLogFile, "%s/log/%s/log_mobile_%d.txt", pStruConf->sCurDir, pStruConf->sCurProj, pStruPC->iRid);
		memcpy(pStruPC->sRouterID, (pStruLD)->sRouterID, strlen((pStruLD)->sRouterID));
	}
	else
	{
		sprintf(pStruPC->sLogFile, "%s/log/%s/log_gateway_%d.txt", pStruConf->sCurDir, pStruConf->sCurProj,pStruPC->iRid);
	}

	pStruPC->pConnFunc = push_client_uping;
	PUSH_CLIENT_CALLOC(pStruPC->pusMapPortCnt, unsigned short, 1);
	PUSH_CLIENT_CALLOC(pStruPC->pusAssistantCnt, unsigned short, 1);
	PUSH_CLIENT_CALLOC(pStruPC->pStruAssistantInfo, PCNatLink, pStruConf->iMapCnt + 2);
	PUSH_CLIENT_CALLOC(pStruPC->pStruED, PCEventData, pStruConf->iMapCnt + 1 + 1);
	PUSH_CLIENT_CALLOC(pStruPC->puiResult, unsigned int, 1);
	PUSH_CLIENT_CALLOC(pStruPC->piRealClient, int, 1);
	PUSH_CLIENT_CALLOC(pStruPC->sRandKey, char, PUSH_CLIENT_RAND_KEY_LENGTH);
	PUSH_CLIENT_CALLOC(pStruPC->puiStatus, unsigned int, 1);
	PUSH_CLIENT_CALLOC(pStruPC->puiHubStatus, unsigned int, 1);
	PUSH_CLIENT_CALLOC(pStruPC->puiHubTick, unsigned int, 1);
	PUSH_CLIENT_CALLOC(pStruPC->pStruSendData, struct timespec, 1);
	PUSH_CLIENT_CALLOC(pStruPC->pStruHubSendData, struct timespec, 1);
	*(pStruPC->puiStatus) = PUSH_CLIENT_STATUS_CONNECT_TO_NAT_SERVER;
	PUSH_CLIENT_CALLOC(pStruPC->puiTick, unsigned int, 1);
	*(pStruPC->puiTick) = 127;
	*(pStruPC->puiHubTick) = 127;
	//PC_RESULT("*******************************************************%d:%p\n", iTmp, pStruPC->puiResult);
	
	PUSH_CLIENT_CALLOC(pStruPC->pStruHead, struct list_head, 1);
	INIT_LIST_HEAD(pStruPC->pStruHead);
	PUSH_CLIENT_CALLOC(pStruPC->pStruConnectHead, struct list_head, 1);
	INIT_LIST_HEAD(pStruPC->pStruConnectHead);
	PUSH_CLIENT_CALLOC(pStruPC->pStruAssistantHead, struct list_head, 1);
	INIT_LIST_HEAD(pStruPC->pStruAssistantHead);

	PUSH_CLIENT_CALLOC(pStruPC->pStruConnectMutex, pthread_mutex_t, 1);
	pthread_mutex_init(pStruPC->pStruConnectMutex, NULL);
	PUSH_CLIENT_CALLOC(pStruPC->pStruAssistantMutex, pthread_mutex_t, 1);
	pthread_mutex_init(pStruPC->pStruAssistantMutex, NULL);
	PUSH_CLIENT_CALLOC(pStruPC->pStruResultMutex, pthread_mutex_t, 1);
	pthread_mutex_init(pStruPC->pStruResultMutex, NULL);
	pthread_mutex_init(&pStruPC->struProjDataMutex, NULL);

	PUSH_CLIENT_CALLOC(pStruPC->pStruInterfaceHead, PCInterfaceHead, 1);
	//PC_ERROR("haed = %p\n", pStruConf->pStruHead->pStruNext);
	push_client_head_copy(pStruConf->pStruHead, pStruPC->pStruInterfaceHead);
	clock_gettime(CLOCK_MONOTONIC, pStruPC->pStruSendData);

	/*PUSH_CLIENT_CALLOC(pStruPC->pStruED, PCEventData, pStruConf->iMapCnt);
	PUSH_CLIENT_CALLOC(pStruPC->puiResult, unsigned int, 1);
	PUSH_CLIENT_CALLOC(pStruPC->sRandKey, char, PUSH_CLIENT_RAND_KEY_LENGTH);
	PUSH_CLIENT_CALLOC(pStruPC->puiStatus, unsigned int, 1);
	PUSH_CLIENT_CALLOC(pStruPC->pStruSendData, struct timespec, 1);
	*(pStruPC->puiStatus) = PUSH_CLIENT_STATUS_CONNECT_TO_NAT_SERVER;
	PUSH_CLIENT_CALLOC(pStruPC->puiTick, unsigned int, 1);
	*(pStruPC->puiTick) = 127;

	PUSH_CLIENT_CALLOC(pStruPC->pStruResultMutex, pthread_mutex_t, 1);
	pthread_mutex_init(pStruPC->pStruResultMutex, NULL);
	INIT_LIST_HEAD(&pStruPC->struUrlList);
	clock_gettime(CLOCK_MONOTONIC, pStruPC->pStruSendData);
	
	pthread_mutex_init(&pStruPC->struUrlMutex, NULL);
	push_client_get_url_data(pStruConf, pStruPC);*/
} 

static int
push_client_create_tcp_listen(
	unsigned short usMapCnt,
	unsigned short usPort,
	PCConfig			 *pStruConf,
	PushClient		 *pStruPC,
	int						 *piListenFd
)
{
	int iRet = 0;
	int iSize = sizeof(struct sockaddr_in);
	void *pData = NULL;
	struct sockaddr_in struAddr;

	(*piListenFd) = socket(AF_INET, SOCK_STREAM, 0);
	if( (*piListenFd) < 0 )
	{
		PC_ERROR("socket error : %s\n", strerror(errno));
		exit(0);
	}

	struAddr.sin_addr.s_addr = inet_addr("127.0.0.1");
	//struAddr.sin_addr.s_addr = pStruPC->struClientIP.s_addr;
	struAddr.sin_port = ntohs(usPort);
	struAddr.sin_family = AF_INET;

	iRet = push_client_set_listen_sockopt((*piListenFd));
	if( iRet != PUSH_CLIENT_OK )
	{
		exit(0);
	}

	iRet = bind((*piListenFd), (struct sockaddr*)&struAddr, sizeof(struAddr));
	if( iRet < 0 )
	{
		PC_ERROR("bind error: %s\n", strerror(errno));
		exit(0);
	}	

	iRet = listen((*piListenFd), 10);
	if( iRet < 0 )
	{
		PC_ERROR("listen error: %s\n", strerror(errno));
		exit(0);
	}

	pStruPC->iEvents = (EPOLLONESHOT | EPOLLET | EPOLLIN);	
	push_client_get_pushclient_data(pStruPC->struClientIP.s_addr, pStruPC->usClientPort, &pData);

	return push_client_add_listen_sockfd(usMapCnt, (*piListenFd), pData, pStruPC);	
}

static int 
push_client_create(
	PCLinkData		 *pStruLD,
	struct in_addr struIP,
	unsigned short usPort
)
{
	int iRet = 0; 
	int iCount = 0;
	int iSockfd = 0;
	int iResult = 0;
	unsigned short usMapPortCnt = 0;
	PushClient *pStruPC = NULL;	
	PCConfig *pStruConf = NULL;

	push_client_get_config_ptr(&pStruConf);

	if (pStruConf->iType == PUSH_CLIENT_TYPE_SERVER)
	{
		iRet = push_client_create_socket(
					PUSH_CLIENT_PROTO_TCP, 
					struIP,
					usPort, 
					pStruConf, 
					&iSockfd);
		if( iRet != PUSH_CLIENT_OK )	
		{
			return iRet;
		}
	}

	pthread_mutex_lock(&gStruSCMutex);
	pStruLD->iRID = giSendCount++;
	//PC_ERROR("giSendCount = %d, iTotalLink =%d\n", giSendCount, pStruConf->iTotalLink);
	if( giSendCount > pStruConf->iTotalLink )
	{
		iRet = PUSH_CLIENT_ERR;
	}
	pthread_mutex_unlock(&gStruSCMutex);
	if( iRet != PUSH_CLIENT_OK )
	{
		return PUSH_CLIENT_FAIL_SOCKET_FULL;
	}

	//memset(&struPC, 0, sizeof(struPC));	
		
	//push_client_get_pushclient_data(struIP.s_addr, usPort, (void**)&pStruPC);
	push_client_get_pushclient_data_by_offset(pStruLD->iRID * sizeof(PushClient), (void**)&pStruPC);
	PC_ERROR("ip = %s, usPort = %d, pStruPC = %p\n", inet_ntoa(struIP), usPort, pStruPC);

	if( pStruConf->iConnectNAT != 1 )
	{
		return PUSH_CLIENT_OK;
	}
	PC_DEBUG("iRID = %d\n", pStruLD->iRID);
	push_client_init_client(pStruLD, struIP, usPort, pStruConf, pStruPC);	
	pStruPC->iNatSockfd = iSockfd;

//	pthread_mutex_lock(pStruPC->pStruAssistantMutex);
//	usMapPortCnt = (*pStruPC->pusMapPortCnt);
//	pthread_mutex_unlock(pStruPC->pStruAssistantMutex);
	//为了防止在接收的时候数据还未写入,所以在此先写入部分数据
	//push_client_write_mmap_data(struIP.s_addr, usPort, &struPC);

	if( pStruConf->iProtocol == PUSH_CLIENT_PROTO_TCP )
	{
		if( pStruConf->iType != PUSH_CLIENT_TYPE_SERVER )
		{
			//iRet = push_client_create_tcp_link(usMapPortCnt,pStruConf,pStruPC,pStruPC->struServerIP.s_addr,pStruPC->usServerPort,usPort,&pStruPC->iNatSockfd);
			PC_ERROR2(pStruPC->sLogFile, "\n");
			iResult = push_client_execute_cmd(pStruPC->pStruInterfaceHead, (void*)pStruPC);
			goto end;
		}
		else
		{
			iRet = push_client_create_tcp_link(usMapPortCnt,pStruConf,pStruPC,pStruPC->struServerIP.s_addr,pStruPC->usServerPort,usPort,&pStruPC->iNatSockfd);
			//PC_ERROR2(pStruPC->sLogFile, "iNatSockfd = %d, %p\n", pStruPC->iNatSockfd, pStruPC);
			//iRet = push_client_create_tcp_link(usMapPortCnt,pStruConf,&struPC,struPC.struServerIP.s_addr,struPC.usServerPort,usPort,&struPC.iNatSockfd);
			/* 发送建立连接之后再开始进行检查 */
		/*	if( pStruPC->uiAddCheck == 1 )
			{
				pStruPC->uiAddCheck = 0;
				push_client_add_recv_check(pStruPC);
			}*/
		}
	}
	else
	{
		iRet = push_client_create_udp_link(usMapPortCnt, pStruPC->struServerIP.s_addr, pStruPC->struClientIP.s_addr, pStruConf->usServerStartPort, usPort, pStruConf, pStruPC, &pStruPC->iNatSockfd);
	}	
	if( iRet != PUSH_CLIENT_FAIL_SOCKET_FULL && iRet != PUSH_CLIENT_FAIL_BIND_SOCKET_ERR )
	{
		if( iRet != PUSH_CLIENT_OK )
		{
			push_client_set_fail_value(PUSH_CLIENT_CONNECT_TO_SERVER, iRet, pStruPC);
			goto err;
		}
		if( pStruPC->uiAddCheck == 1 )
		{
			pStruPC->uiAddCheck = 0;
			*pStruPC->puiTick = 0;
			PC_ERROR2(pStruPC->sLogFile, "add recv_check\n");
			push_client_add_recv_check(pStruPC);
		}
	}

	goto end;
err:
	iResult = PUSH_CLIENT_ERR;
end:
	return iResult;
}

static int
push_client_handle_create_link(
	struct list_head *pStruHead
)
{
	int iRet = 0;
	PCLinkData *pStruLD = NULL;
  PCCreateLink *pStruCL = NULL;

	if( !pStruHead )
	{
		return PUSH_CLIENT_ERR;
	}
	pStruCL = list_entry(pStruHead, PCCreateLink, struNode);

	iRet = push_client_create((PCLinkData*)pStruCL->pData, pStruCL->struAddr, pStruCL->usPort);

	pStruLD = (PCLinkData *)pStruCL->pData;
//	PUSH_CLIENT_FREE(pStruLD->pStruDev);
	if( pStruLD->pStruRouter )
	{
		cJSON_Delete(pStruLD->pStruRouter);
	}
	PUSH_CLIENT_FREE(pStruCL->pData);
	PUSH_CLIENT_FREE(pStruCL);

	return iRet;
}

static void
push_client_free_create_link(
	struct list_head *pStruHead
)
{
	PCCreateLink *pStruCL = NULL;

	if( !pStruHead )
	{
		return;
	}

	pStruCL = list_entry(pStruHead, PCCreateLink, struNode);

	PUSH_CLIENT_FREE(pStruCL->pData);
	PUSH_CLIENT_FREE(pStruCL);
}

int
push_client_start_create_link(
	struct in_addr struAddr,
	unsigned short usPort,
	void					 *pData
)
{
	PCCreateLink *pStruCL = NULL;
	
	PUSH_CLIENT_CALLOC(pStruCL, PCCreateLink, 1);
	pStruCL->struAddr = struAddr;
	pStruCL->usPort = usPort;
	pStruCL->pData = pData;

	return push_client_add_thread_pool_node(giThreadID, &pStruCL->struNode);
}

int 
push_client_init_create_link(
	int iThreadNum
)
{
	PC_DEBUG("\n");
	PC_DEBUG("iThreadNum = %d\n", iThreadNum);
	sem_init(&gSem, 0, 0);
	push_client_create_thread_pool(iThreadNum, "create_link", push_client_free_create_link, NULL, push_client_handle_create_link, &giThreadID);
	PC_DEBUG("giTHerad = %d\n", giThreadID);

	return PUSH_CLIENT_OK;
}

int 
push_client_uninit_create_link()
{
	sem_destroy(&gSem);
	pthread_mutex_destroy(&gStruPDCMutex);
	return 1;
}

int
push_client_timedwait_create_link()
{
	sem_wait(&gSem);
}

int
push_client_post_create_link()
{
	sem_post(&gSem);
}

static void
push_client_wait_create_link_time(
	int							iCount,
	struct timespec *pStruStartTime, 
	PCConfig				*pStruConf
)
{
	int iUsec = 0;
	struct timespec struProcessTime;

	clock_gettime(CLOCK_MONOTONIC, &struProcessTime);
	struProcessTime.tv_sec -= pStruStartTime->tv_sec;
	struProcessTime.tv_nsec -= pStruStartTime->tv_nsec;
	iUsec = struProcessTime.tv_sec * 1000 * 1000 + 
					struProcessTime.tv_nsec / (1000);
	//PC_DEBUG("iUser = %d, createlinktime = %d\n", iUsec, pStruConf->iCreateLinkTime);
	if( iUsec >= pStruConf->iCreateLinkTime )
	{
		PC_DEBUG("In %d us, create %d link\n", iUsec, iCount);
		if( iCount < pStruConf->iSendDataCnt )
		{
			PC_ERROR( "In %d us, we cannot create %d link\n", pStruConf->ulPushDataSendTime, pStruConf->iSendDataCnt );
			exit(0);
		}
	}
	else
	{
		iUsec = pStruConf->iCreateLinkTime - iUsec;
	}
	if( iCount % pStruConf->iCreateLink == 0 )
	{
	//	PC_DEBUG("iUSec = %d, createLinkTim = %ld\n", iUsec,  pStruConf->iCreateLinkTime);
		//push_client_set_reset();
		usleep(iUsec);
		clock_gettime(CLOCK_MONOTONIC, pStruStartTime);
	}
}

static void
push_client_set_routerid(
	int			 iCount,
	PCConfig *pStruConfig, 
	int			 *piRouterID 
)
{
	if(pStruConfig->iType == PUSH_CLIENT_TYPE_CLIENT)
	{
		if( iCount != 0 && iCount % pStruConfig->iMapCnt == 0 )
		{
			(*piRouterID)++;
		}
	}
	else
	{
		if( iCount != 0 )
		{
			(*piRouterID)++;
		}
	}
//	PC_ERROR("piRouterID = %d\n", *piRouterID);
}

static void
push_client_get_sRouterID(
	int iRID,
	char *sFilePath,
	char *sRouterID
)
{
	int iOffset = 0;
	int iLineSize = PUSH_CLIENT_ROUTERID_LENGTH;
	FILE *pFp = NULL;

	pFp = fopen(sFilePath, "r");
	if( !pFp )
	{
		PC_ERROR("fopen %s error : %s\n", sFilePath, strerror(errno));
		exit(0);
	}

	iOffset = iLineSize * iRID;
//	PC_ERROR("iRID = %d,iOffset = %d\n", iRID, iOffset);
	fseek(pFp, iOffset, SEEK_SET);

	fread(sRouterID, sizeof(char), PUSH_CLIENT_ROUTERID_LENGTH, pFp);

	fclose(pFp);

	PC_ERROR("++++++++++++sRouterID = %s\n", sRouterID);
}


static void
push_client_alloc_link_data(
	int				 iRouterID, 
	PCConfig	 *pStruConf,
	PCLinkData **ppStruLD
)
{
	int iPos = 0;
	char *sTmp = NULL;


	PUSH_CLIENT_CALLOC((*ppStruLD), PCLinkData, 1);
	(*ppStruLD)->iRID = iRouterID;
	push_client_get_sRouterID((*ppStruLD)->iRID, pStruConf->sUserCenterFile, (*ppStruLD)->sRouterID);
	//push_client_read_file_data(iRouterID, PUSH_CLIENT_QT_LENGTH, pStruConf->sQtPath, (*ppStruLD)->sQt);
	//push_client_read_file_data(iRouterID, PUSH_CLIENT_UID_LENGTH, pStruConf->sUidPath, (*ppStruLD)->sUid );

	//PUSH_CLIENT_CALLOC((*ppStruLD)->pStruDev, PCDevice, 1);
	/*if( pStruConf->iType == PUSH_CLIENT_TYPE_CLIENT )
	{
	}*/
	/*else
	{
		iPos = random()	% pStruConf->iRouterCnt;
		push_client_get_sRouterID(iRouterID, pStruConf->iRouterCnt, iPos, pStruConf->sRidPath, (*ppStruLD)->sRouterID);
	}*/
	//push_client_read_file_data(iRouterID, PUSH_CLIENT_UID_LENGTH, pStruConf->sUidPath, (*ppStruLD)->sUid);

	/*if( pStruConf->iType == PUSH_CLIENT_TYPE_CLIENT )
	{
		push_client_set_device((*ppStruLD)->pStruDev);
	}*/
/*	if( pStruConfig->iType == PUSH_CLIENT_TYPE_CLIENT )
	{
		push_client_get_token_userid((*ppStruLD)->sToken, (*ppStruLD)->sUserID);
	}*/
}

static void *
push_client_create_link_thread(
	void *pData
)
{
	int i = 0, j = 0;
	int iRet = 0;
	int iCount = 0, iTotalCnt = 0;
	int iOffset = 0;
	int iRouterID = 0;
	unsigned short usEndPort = 0;
	unsigned int uiStartIP = 0;
	struct in_addr struAddr;
	struct timespec struStartTime, struProcessTime;
	PCConfig *pStruConfig = (PCConfig *)pData;
	PCLinkData *pStruLD = NULL;

	uiStartIP = pStruConfig->uiStartIP;
	//这里并不涉及到手机与客户端的直接连接，因此不需要为此分配端口
	//
	iOffset = pStruConfig->iMapCnt;
	iCount = pStruConfig->usEndPort - pStruConfig->usStartPort;
	usEndPort = (iCount - iCount % iOffset) + pStruConfig->usStartPort;
	iCount = 0;
	//PC_DEBUG("iOffsetr = %d, usEndPort = %d\n", iOffset, usEndPort);
	pthread_detach(pthread_self());
	clock_gettime(CLOCK_MONOTONIC, &struStartTime);
	push_client_timedwait_create_link();
	PC_ERROR("----------------------- iTotalLInk = %d\n", pStruConfig->iTotalLink);
	for( i = 0; i < pStruConfig->iIPCount; i++ )
	{
		if( pStruConfig->iIPDirect == 1 )
		{
			uiStartIP += 1<<24;
		}
		else
		{
			uiStartIP -= 1<<24;
		}
		for( j = pStruConfig->usStartPort; j < usEndPort; j+=iOffset )
		{
			iRet = push_client_check_exit();
			if( iRet == PUSH_CLIENT_OK )
			{
				i = pStruConfig->iIPCount;
				j = usEndPort;
				continue;
			}
			struAddr.s_addr = uiStartIP;
			push_client_set_routerid(iCount, pStruConfig, &iRouterID);

			push_client_alloc_link_data(iRouterID, pStruConfig, &pStruLD);
			
			iRet = push_client_start_create_link(struAddr, j, (void*)pStruLD);
			if( iRet != PUSH_CLIENT_OK )
			{
				push_client_set_exit();
				break;
			}
			iCount++;
			iTotalCnt = iCount;
/*			pthread_mutex_lock(&gStruSCMutex);
			iTotalCnt = giSendCount;
			pthread_mutex_unlock(&gStruSCMutex);*/
			if( iTotalCnt >= pStruConfig->iTotalLink )
			{
				i = pStruConfig->iIPCount;
				break;
			}
			if( pStruConfig->iCreateLinkTime > 0 )
			{
				if( iCount % pStruConfig->iCreateLink == 0 )
				{
					usleep(pStruConfig->iCreateLinkTime);
				}
			}
		}
	}
	PUSH_CLIENT_FREE(pData);
}

int
push_client_create_link()
{
	pthread_t th;
	PCConfig *pStruConf = NULL;

	PUSH_CLIENT_CALLOC(pStruConf, PCConfig, 1);
	push_client_get_config(pStruConf);

	if( pthread_create(&th, NULL, push_client_create_link_thread, (void*)pStruConf) < 0 )
	{
		PC_ERROR("pthread_create error: %s\n", strerror(errno));
		return PUSH_CLIENT_ERR;
	}

	return PUSH_CLIENT_OK;
}

int
push_client_write_mmap_data(
	unsigned int uiIP,
	unsigned short usPort,
	PushClient *pStruPC
)
{
	
//	if( pStruPC->usInit )
	//{
		//return push_client_write_part_mmap_data(uiIP, usPort, pStruPC);
	//}
//	else
/*	if( pStruPC->usInit == 0 )
	{
		return push_client_write_all_mmap_data(uiIP, usPort, pStruPC);
	}*/
}

