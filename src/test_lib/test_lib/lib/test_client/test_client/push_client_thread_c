
#include "tc_comm.h"

#define PUSH_CLIENT_THREAD_GROUP 10
#define PUSH_CLIENT_THREAD_LIST_LEN  50  //本来使用限制每个线程可处理的任务书的,后面发现这完全没用,所以目前是丢弃该配置的;

typedef struct _PCThreadData
{
	char *sThreadName;
	int iThreadGroupID;
	int iThreadMemberID;
}PCThreadData, *PPCThreadData;

typedef struct _PCThreadMember
{
	int							iCount;					  //已经链接个数, 最大个数为PUSH_CLIENT_THREAD_LIST_LEN
	pthread_mutex_t  struThreadMutex; //每个链表的锁
	pthread_cond_t   struThreadCond;  //每个链表的条件变量
	struct list_head struThreadList;  //链表数组
	struct list_head struNode;				//加入组链表
}PCThreadMember, *PPCThreadMemeber;

typedef struct _PCThreadGroup
{
	int iCount;																					//线程组成员个数
	PCThreadMember *pStruTM;			 											//线程组成员数组
	void (*group_free)(struct list_head *pStruNode);		//节点释放函数
	int  (*group_func)(struct list_head *pStruNode);		//在分派任务到成员线程之前做的事情
	int  (*execute_func)(struct list_head *pStruNode );	//线程组执行函数
	pthread_mutex_t struGroupMutex;											//组控制线程锁
	pthread_mutex_t struFreeMutex;
	pthread_mutex_t struBusyMutex;
	pthread_cond_t  struGroupCond;									  	//组控制线程条件变量
	struct list_head struGroupHead;											//组链表
	struct list_head struFreeMember;										//空闲线程
	struct list_head struBusyMember;										//忙碌线程
}PCThreadGroup, *PPCThreadGroup;

static int giThreadGroupCnt = 0;
static pthread_condattr_t gStruCondAttr;
static PCThreadGroup gStruThreadTable[PUSH_CLIENT_THREAD_GROUP];
//static pthread_mutex_t gCountMutex = PTHREAD_MUTEX_INITIALIZER;
//static int iCount = 0;
//static pthread_mutex_t gStruTableMutex[PUSH_CLIENT_THREAD_GROUP];

static int tc_get_thread_group_node( int ID, struct list_head **pStruNode );
static int
tc_get_thread_member_node(
	int iSecond,
	int iThreadGroupID,
	int iThreadMembID,
	struct list_head **pStruNode
);

int
tc_init_thread_pool()
{
	int i = 0;

	memset( gStruThreadTable, 0, sizeof(gStruThreadTable) );
	memset(&gStruCondAttr, 0, sizeof(gStruCondAttr));
	pthread_condattr_init(&(gStruCondAttr));
	pthread_condattr_setclock(&(gStruCondAttr), CLOCK_MONOTONIC);

	for(; i < PUSH_CLIENT_THREAD_GROUP; i++ )
	{
		pthread_mutex_init(&gStruThreadTable[i].struGroupMutex, NULL);
		pthread_mutex_init(&gStruThreadTable[i].struFreeMutex, NULL);
		pthread_mutex_init(&gStruThreadTable[i].struBusyMutex, NULL);
		pthread_cond_init(&gStruThreadTable[i].struGroupCond, &gStruCondAttr);
		INIT_LIST_HEAD(&gStruThreadTable[i].struGroupHead);
		INIT_LIST_HEAD(&gStruThreadTable[i].struFreeMember);
		INIT_LIST_HEAD(&gStruThreadTable[i].struBusyMember);
	}
	
	return PUSH_CLIENT_OK;
}

int 
tc_uninit_thread_pool()
{
	int i = 0, j = 0;
	struct list_head *pStruSL = NULL;

	//tc_set_exit();
	
	//给予5秒等待线程退出, 有点长,慢慢调哇
	//sleep(5);

	for( ; i < PUSH_CLIENT_THREAD_GROUP; i++ )
	{
		for( j = 0; j < gStruThreadTable[i].iCount; j++ )
		{
			if( !(gStruThreadTable[i].pStruTM) )
			{
				continue;
			}
			if( list_empty(&gStruThreadTable[i].pStruTM[j].struThreadList) )
			{
				continue;
			}

			pStruSL = gStruThreadTable[i].pStruTM[j].struThreadList.next;
			if( !pStruSL )
			{
				continue;
			}
			while(pStruSL != &gStruThreadTable[i].pStruTM[j].struThreadList)
			{
				list_del_init(pStruSL);
				if( gStruThreadTable[i].group_free )
				{
					gStruThreadTable[i].group_free(
												pStruSL
											);
				}
				pStruSL = gStruThreadTable[i].pStruTM[j].struThreadList.next;
			}

			pthread_mutex_destroy(&gStruThreadTable[i].pStruTM[j].struThreadMutex);
			pthread_cond_destroy(&gStruThreadTable[i].pStruTM[j].struThreadCond);
		}
		PUSH_CLIENT_FREE(gStruThreadTable[i].pStruTM);
	}

	return PUSH_CLIENT_OK;
}

static void *
tc_thread_handle_data(
	void *pArg
)
{
	int iRet = 0;
	PCThreadData *pStruHD = (PPCThreadData)pArg;
	struct list_head *pStruNode = NULL;

	//PC_DEBUG("iGroupID = %d, iMember = %d\n", 
	//						pStruHD->iThreadGroupID, pStruHD->iThreadMemberID);

	if( pStruHD->sThreadName )
	{
		prctl(PR_SET_NAME, pStruHD->sThreadName);
	}

	while(1)
	{
		pStruNode = NULL;

		iRet = tc_check_exit();
		if( iRet == PUSH_CLIENT_OK )
		{
			PC_DEBUG("exit thread %d->%d\n", pStruHD->iThreadGroupID, pStruHD->iThreadMemberID);
			break;
		}
		iRet = tc_get_thread_member_node(
																		1,
																		pStruHD->iThreadGroupID,
																		pStruHD->iThreadMemberID,
																		&pStruNode
																	);
		PC_DEBUG("iRetet = %d\n", iRet);
		if( iRet == PUSH_CLIENT_FAIL_TIMEOUT || pStruNode == NULL )
		{
			continue;
		}
		else if( iRet != PUSH_CLIENT_OK )
		{
			continue;
		}

		PC_DEBUG("iD = group %d, member %d, iRet = %d, %p\n", 
					pStruHD->iThreadGroupID, pStruHD->iThreadMemberID, iRet, pStruNode);
		PC_DEBUG("execute = %p, create_ = %p\n", gStruThreadTable[pStruHD->iThreadGroupID].execute_func, tc_create);
		if( gStruThreadTable[pStruHD->iThreadGroupID].execute_func )
		{
			iRet = gStruThreadTable[pStruHD->iThreadGroupID].execute_func(pStruNode);
/*			pthread_mutex_lock(&gStruThreadTable[pStruHD->iThreadGroupID].struFreeMutex);
			list_add_tail(&gStruThreadTable[pStruHD->iThreadGroupID].pStruTM[pStruHD->iThreadMemberID].struNode, &gStruThreadTable[pStruHD->iThreadGroupID].struFreeMember);
			pthread_mutex_unlock(&gStruThreadTable[pStruHD->iThreadGroupID].struFreeMutex);*/
			if( iRet != PUSH_CLIENT_OK )
			{
				PC_DEBUG("gStruThread execute_func error: %d->%d\n", pStruHD->iThreadGroupID, pStruHD->iThreadMemberID);	
				continue;
			}
		}
		//PC_DEBUG("continue\n");
	}

	PC_DEBUG("*******************************************************\n");
	PUSH_CLIENT_FREE(pStruHD);
	pthread_exit(NULL);
}

static int
tc_get_thread_node(
	struct list_head *pStruHead,
	struct list_head **ppStruNode
)
{
	if( list_empty(pStruHead) )
	{
		return PUSH_CLIENT_ERR;
	}

	(*ppStruNode) = pStruHead->next;
	list_del_init(*ppStruNode);

	return PUSH_CLIENT_OK;
}

static int
tc_get_thread_group_node(
	int ID,
	struct list_head **pStruNode
)
{
	int iRet = 0;
	struct timespec struTS;

	clock_gettime(CLOCK_MONOTONIC, &struTS);
	struTS.tv_sec += 1;
	pthread_mutex_lock(&gStruThreadTable[ID].struGroupMutex);
	iRet = tc_get_thread_node(&gStruThreadTable[ID].struGroupHead, pStruNode);
	PC_DEBUG("iRet = %d\n", iRet);
	if( iRet != PUSH_CLIENT_OK )
	{
		iRet = pthread_cond_timedwait(&gStruThreadTable[ID].struGroupCond, &gStruThreadTable[ID].struGroupMutex, &struTS);
		PC_DEBUG("iRet = %d, errno = %d, ETIMEDOUT = %d\n", iRet, errno, ETIMEDOUT);
		if( iRet == ETIMEDOUT )//list_empty(&gStruThreadTable[ID].struGroupHead) )
		{
			iRet = PUSH_CLIENT_FAIL_TIMEOUT;
		}
		else 
		{
			iRet = tc_get_thread_node(&gStruThreadTable[ID].struGroupHead, pStruNode);
		}
	}
	pthread_mutex_unlock(&gStruThreadTable[ID].struGroupMutex);

	return iRet;
}

static int
tc_add_thread_member_node(
	struct list_head *pStruNode, 
	PCThreadMember *pStruMemb
)
{
	int iRet = 0;

	pthread_mutex_lock(&pStruMemb->struThreadMutex);
	PC_DEBUG("pStruMemb->iCOunt = %d\n", pStruMemb->iCount);
	/*if( pStruMemb->iCount >= PUSH_CLIENT_THREAD_LIST_LEN )
	{
		iRet = PUSH_CLIENT_ERR;
	}
	else*/
	{
		PC_DEBUG("\n");
		PC_DEBUG("\n");
		//pthread_cond_wait(&pStruMemb->struThreadCond);
		list_add_tail(pStruNode,&pStruMemb->struThreadList);
		PC_DEBUG("\n");
		pthread_cond_broadcast(&pStruMemb->struThreadCond);
		PC_DEBUG("\n");
		pStruMemb->iCount++;
		PC_DEBUG("pStruMemb->iCOunt = %d\n", pStruMemb->iCount);
	}
	pthread_mutex_unlock(&pStruMemb->struThreadMutex);

	return PUSH_CLIENT_OK;
}

static int
tc_get_thread_member_node(
	int iSecond,
	int iThreadGroupID,
	int iThreadMembID,
	struct list_head **pStruNode
)
{
	int iRet = PUSH_CLIENT_OK;
	struct timespec struTV;

	PC_DEBUG("iGroupID = %d, memberid = %d\n", iThreadGroupID, iThreadMembID);
	//使用CLOCK_MONOTONIC, 采用系统开机时间所经过的秒数,可以让事件更加的准确,因为直接使用REAL_TIME形式,会出现事件不准的情况

	//PC_DEBUG("iThreadMembID = %d, group = %d\n", iThreadMembID, iThreadGroupID);
	PCThreadMember *pStruMemb = &gStruThreadTable[iThreadGroupID].pStruTM[iThreadMembID];
	pthread_mutex_lock(&pStruMemb->struThreadMutex);
	iRet = tc_get_thread_node(&pStruMemb->struThreadList, pStruNode);
	if( iRet != PUSH_CLIENT_OK )
	{
		clock_gettime(CLOCK_MONOTONIC, &struTV);
		struTV.tv_sec += 1;
		iRet = pthread_cond_timedwait(&pStruMemb->struThreadCond, &pStruMemb->struThreadMutex, &struTV);	
		//PC_DEBUG("iRet = %d, errno = %d\n", iRet, errno);
		if( iRet == ETIMEDOUT )// list_empty(&pStruMemb->struThreadList) )
		{
			iRet = PUSH_CLIENT_FAIL_TIMEOUT;
		}	
		else //这里没有做其他错误的判断,是因为拿不准其他错误判断, 所以统一使用是链表是否为空来判断是否可以进行处理
		{
			iRet = tc_get_thread_node(&pStruMemb->struThreadList, pStruNode);
			pStruMemb->iCount--;
		}
	}
	else
	{
		pStruMemb->iCount--;
	}
	pthread_mutex_unlock(&pStruMemb->struThreadMutex);
	
	return iRet;
}

static int
tc_get_free_member(
	PCThreadGroup *pStruTG,
	PCThreadMember **ppStruTM
)
{
	//memset(&struTV, 0, sizeof(struTV));	
	pthread_mutex_lock(&pStruTG->struFreeMutex);
	if( list_empty(&pStruTG->struFreeMember) )
	{
		pthread_mutex_unlock(&pStruTG->struFreeMutex);
		return PUSH_CLIENT_ERR;
	}
	*ppStruTM = list_entry(pStruTG->struFreeMember.next, PCThreadMember, struNode);
	list_del_init(&(*ppStruTM)->struNode);
	pthread_mutex_unlock(&pStruTG->struFreeMutex);

	/*pthread_mutex_lock(&pStruTG->struBusyMutex);
	list_add_tail(&(*ppStruTM)->struNode, pStruTG->struBusyMember);
	pthread_mutex_unlock(&pStruTG->struBusyMutex);*/

	return PUSH_CLIENT_OK;
}

static void *
tc_master_thread(
	void *pData
)
{
	int i = 0;
	int iRet = 0;
	int ID = 0; 
	PCThreadData *pStruTD = (PCThreadData*)pData;
	int iCount = 0;
	static int iCnt = 0;
	char *sName = NULL;
	struct list_head *pStruNode = NULL;
	PCThreadMember *pStruTM = NULL;

	ID = pStruTD->iThreadGroupID;
	if( pStruTD->sThreadName )
	{
		PUSH_CLIENT_CALLOC(sName, char, 256);
		sprintf(sName, "%s_master", pStruTD->sThreadName);
		prctl(PR_SET_NAME, sName);
		PUSH_CLIENT_FREE(sName);
	}

	PUSH_CLIENT_FREE(pData);
	//PC_DEBUG("ID = %d\n", ID);

	while(1)
	{
		PC_DEBUG("\n");
		iRet = tc_check_exit();
		if( iRet == PUSH_CLIENT_OK )
		{
			break;
		}
		iRet = tc_get_thread_group_node( ID, &pStruNode );
		if( iRet == PUSH_CLIENT_FAIL_TIMEOUT )
		{
			continue;
		}
		else if( iRet != PUSH_CLIENT_OK )
		{
			break;
		}

		PC_DEBUG("master %d iRet = %d, iCount = %d\n", ID, iRet, gStruThreadTable[ID].iCount);
		//这里用于处理线程组中,在用线程处理不同任务之前所需要共同处理的部分,这里最好尽量少花时间
		if( gStruThreadTable[ID].group_func ) 
		{
			iRet = gStruThreadTable[ID].group_func(pStruNode);
			PC_DEBUG("mater return = %d\n", iRet);
			if( iRet != PUSH_CLIENT_OK )
			{
				continue;
			}
		}
		PC_DEBUG("\n");
/*		iRet = tc_get_free_member(&gStruThreadTable[ID], &pStruTM);
		if( iRet != PUSH_CLIENT_OK )
		{
			pthread_mutex_lock(&gStruThreadTable[ID].struGroupMutex);
			list_add_tail(pStruNode, &gStruThreadTable[ID].struGroupHead);
			pthread_mutex_unlock(&gStruThreadTable[ID].struGroupMutex);
		}
		else
		{
			tc_add_thread_member_node(pStruNode, pStruTM);
			pStruTM = NULL;
		}*/
		for( i = iCount; i < gStruThreadTable[ID].iCount; i++ )
		{
			PC_DEBUG(" ID = %d,i = %d\n", ID, i);
			iRet = tc_add_thread_member_node(pStruNode, &gStruThreadTable[ID].pStruTM[i]);
			PC_DEBUG("add memct ret = %d\n", iRet);
			if( iRet == PUSH_CLIENT_OK )
			{
				break;
			}
		}
		if( i + 1 == gStruThreadTable[ID].iCount || i == gStruThreadTable[ID].iCount )
		{
			i = 0;
		}
		i++;
		iCount = i;
		if( iCount == gStruThreadTable[ID].iCount )
		{
			iCount = 0;
		}
	}
	PC_DEBUG("8888*******************************************************\n");
	pthread_exit(NULL);
}

static int
tc_create_master_thread(
	char					 *sThreadName,
	int						 iThreadID,
	pthread_attr_t *pStruAttr,
	PCThreadGroup  *pStruGrp
)
{
	pthread_t th;
	int *piID = 0;
	PCThreadData *pStruTD = NULL;

	PUSH_CLIENT_CALLOC(pStruTD, PCThreadData, 1);
	//PUSH_CLIENT_CALLOC(piID, int, 1);
	/*piID = (int *)calloc(1, 4);
	if( !piID )
	{
		PC_ERROR( "calloc error: %s\n", strerror(errno) );
		exit(0);
	}*/
	pStruTD->iThreadGroupID = iThreadID;
	pStruTD->sThreadName    = sThreadName;
	//(*piID) = iThreadID;
	if( pthread_create(&th, pStruAttr, tc_master_thread, (void*)pStruTD) < 0 )
	{
		PC_ERROR( "pthread_create: %s\n", strerror(errno) );
		return PUSH_CLIENT_ERR;
	}
	piID = NULL;	
	return PUSH_CLIENT_OK;
}

static int
tc_init_thread_member(
	PCThreadGroup *pStruGrp,
	PCThreadMember *pStruTM
)
{
	pthread_mutex_init(&pStruTM->struThreadMutex, NULL);
	pthread_cond_init(&pStruTM->struThreadCond, &gStruCondAttr);
	INIT_LIST_HEAD(&pStruTM->struThreadList);
	pthread_mutex_lock(&pStruGrp->struFreeMutex);
	list_add_tail(&pStruTM->struNode, &pStruGrp->struFreeMember);
	pthread_mutex_unlock(&pStruGrp->struFreeMutex);
}

static int
tc_create_member_thread(
	char					 *sThreadName,
	int						 iThreadID,
	pthread_attr_t *pStruAttr,
	PCThreadGroup  *pStruGrp
)
{
	int i = 0;
	int iNum = pStruGrp->iCount;
	pthread_t th;
	PCThreadData *pStruData = NULL;

	PUSH_CLIENT_CALLOC(pStruGrp->pStruTM, PCThreadMember, iNum);
	/*pStruGrp->pStruTM = (PCThreadMember*)calloc(iNum, sizeof(PCThreadMember));
	if( !pStruGrp->pStruTM )
	{
		PC_ERROR("calloc error: %s\n", strerror(errno));
		return PUSH_CLIENT_ERR;
	}*/
	//PC_DEBUG("iNum = %d\n", iNum);

	for( ; i < iNum; i++ )	
	{
		PUSH_CLIENT_CALLOC(pStruData, PCThreadData, 1);
		/*pStruData = (PCThreadData*)calloc(1, sizeof(PCThreadData));
		if(!pStruData)
		{
			PC_ERROR( "calloc: %s", strerror(errno) );
			exit(0);
		}*/
		pStruData->iThreadGroupID = (iThreadID);
		pStruData->iThreadMemberID = i;
		pStruData->sThreadName = sThreadName;
		tc_init_thread_member(
																pStruGrp,	
																&pStruGrp->pStruTM[i]
															);
		while( 1 )
		{
			if( pthread_create(&th, pStruAttr, tc_thread_handle_data, pStruData) )
			{
				PC_ERROR( "pthread_create: %s\n", strerror(errno));
				if( errno == EAGAIN )
				{
					usleep(20);
					continue;
				}
				return PUSH_CLIENT_ERR;
			}
			break;
		}

		pStruData = NULL;
	}

	return PUSH_CLIENT_OK;
}

int
tc_create_thread_pool(
	int  iSize,
	char *sThreadName,
	void (*group_free)(struct list_head *),
	int  (*group_func)(struct list_head *),
	int  (*execute_func)(struct list_head *),
	int  *piThreadID
)
{
	int i = 0;
	int iRet = 0;
	int iNum = 0;
	int ID = 0;
	pthread_attr_t struAttr;

	(*piThreadID) = giThreadGroupCnt;
	giThreadGroupCnt++;

	if( iSize < 0 )
	{
		iNum = 50;
	}
	else
	{
		iNum = iSize;
	}
	gStruThreadTable[(*piThreadID)].iCount = iNum;
	gStruThreadTable[(*piThreadID)].execute_func = execute_func;
	gStruThreadTable[(*piThreadID)].group_free = group_free;
	gStruThreadTable[(*piThreadID)].group_func = group_func;

	//PC_DEBUG("[%d]iCOunt = %d\n", (*piThreadID), gStruThreadTable[(*piThreadID)].iCount);

	pthread_attr_init(&struAttr);
	//线程大小设置为128K, 感觉有点高了, 后期慢慢调整, 就目前线程使用数的上线来说,其实16K已经大大的满足了,以后可以测试一下
	pthread_attr_setstacksize(&struAttr, 8 * 1024); 
	//设置为离散状态,由系统自动回收线程资源
	pthread_attr_setdetachstate(&struAttr, PTHREAD_CREATE_DETACHED);

	iRet = tc_create_master_thread(sThreadName, *piThreadID, &struAttr, &gStruThreadTable[(*piThreadID)]);
	if( iRet != PUSH_CLIENT_OK )
	{
		return iRet;
	}
	
	pthread_attr_setstacksize(&struAttr, 256 * 1024); 
	return tc_create_member_thread(sThreadName, *piThreadID, &struAttr, &gStruThreadTable[(*piThreadID)]);
}

int
tc_add_thread_pool_node(
	int								iThreadID,
	struct list_head  *pStruNode
)
{
	int iRet = 0;

	pthread_mutex_lock(&gStruThreadTable[iThreadID].struGroupMutex);
	list_add_tail(pStruNode, &gStruThreadTable[iThreadID].struGroupHead);
	pthread_cond_broadcast(&gStruThreadTable[iThreadID].struGroupCond);
	pthread_mutex_unlock(&gStruThreadTable[iThreadID].struGroupMutex);

	return PUSH_CLIENT_OK;
}
